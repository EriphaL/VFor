import { __extends, __assign } from 'tslib';
import { INPUT_END, STATUS_POSSIBLE, STATUS_RECOGNIZED, STATUS_FAILED } from '@any-touch/shared';
import Recognizer from '@any-touch/recognizer';
import { getVLength } from '@any-touch/vector';
import { ComputeMaxLength, ComputeDistance } from '@any-touch/compute';

var DEFAULT_OPTIONS = {
    name: 'tap',
    pointLength: 1,
    tapTimes: 1,
    waitNextTapTime: 300,
    maxDistance: 2,
    maxDistanceFromPrevTap: 9,
    maxPressTime: 250,
};
var default_1 = (function (_super) {
    __extends(default_1, _super);
    function default_1(options) {
        var _this = _super.call(this, __assign(__assign({}, DEFAULT_OPTIONS), options)) || this;
        _this.tapCount = 0;
        return _this;
    }
    default_1.prototype._isValidDistanceFromPrevTap = function (center) {
        if (void 0 !== this.prevTapPoint) {
            var distanceFromPreviousTap = getVLength({ x: center.x - this.prevTapPoint.x, y: center.y - this.prevTapPoint.y });
            this.prevTapPoint = center;
            return this.options.maxDistanceFromPrevTap >= distanceFromPreviousTap;
        }
        else {
            this.prevTapPoint = center;
            return true;
        }
    };
    default_1.prototype._isValidInterval = function () {
        var now = performance.now();
        if (void 0 === this.prevTapTime) {
            this.prevTapTime = now;
            return true;
        }
        else {
            var interval = now - this.prevTapTime;
            this.prevTapTime = now;
            return interval < this.options.waitNextTapTime;
        }
    };
    default_1.prototype.recognize = function (input, emit) {
        var inputType = input.inputType, x = input.x, y = input.y;
        this.computed = this.compute([ComputeMaxLength, ComputeDistance], input);
        if (INPUT_END !== inputType)
            return;
        this.status = STATUS_POSSIBLE;
        if (this.test(input)) {
            this.cancelCountDownToFail();
            if (this._isValidDistanceFromPrevTap({ x: x, y: y }) && this._isValidInterval()) {
                this.tapCount++;
            }
            else {
                this.tapCount = 1;
            }
            if (0 === this.tapCount % this.options.tapTimes) {
                this.status = STATUS_RECOGNIZED;
                emit(this.options.name, __assign(__assign({}, this.computed), { tapCount: this.tapCount }));
                this.reset();
            }
            else {
                this.countDownToFail();
            }
        }
        else {
            this.reset();
            this.status = STATUS_FAILED;
        }
    };
    default_1.prototype.countDownToFail = function () {
        var _this = this;
        this._countDownToFailTimer = setTimeout(function () {
            _this.status = STATUS_FAILED;
            _this.reset();
        }, this.options.waitNextTapTime);
    };
    default_1.prototype.cancelCountDownToFail = function () {
        clearTimeout(this._countDownToFailTimer);
    };
    default_1.prototype.reset = function () {
        this.tapCount = 0;
        this.prevTapPoint = void 0;
        this.prevTapTime = void 0;
    };
    default_1.prototype.test = function (input) {
        var startInput = input.startInput, pointLength = input.pointLength;
        var deltaTime = input.timestamp - startInput.timestamp;
        var _a = this.computed, maxPointLength = _a.maxPointLength, distance = _a.distance;
        return maxPointLength === this.options.pointLength &&
            0 === pointLength &&
            this.options.maxDistance >= distance &&
            this.options.maxPressTime > deltaTime;
    };
    return default_1;
}(Recognizer));

export default default_1;
