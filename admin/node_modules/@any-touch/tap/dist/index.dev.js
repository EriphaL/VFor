'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var shared = require('@any-touch/shared');
var Recognizer = _interopDefault(require('@any-touch/recognizer'));
var vector = require('@any-touch/vector');
var compute = require('@any-touch/compute');

var DEFAULT_OPTIONS = {
    name: 'tap',
    pointLength: 1,
    tapTimes: 1,
    waitNextTapTime: 300,
    maxDistance: 2,
    maxDistanceFromPrevTap: 9,
    maxPressTime: 250,
};
var default_1 = (function (_super) {
    tslib.__extends(default_1, _super);
    function default_1(options) {
        var _this = _super.call(this, tslib.__assign(tslib.__assign({}, DEFAULT_OPTIONS), options)) || this;
        _this.tapCount = 0;
        return _this;
    }
    default_1.prototype._isValidDistanceFromPrevTap = function (center) {
        if (void 0 !== this.prevTapPoint) {
            var distanceFromPreviousTap = vector.getVLength({ x: center.x - this.prevTapPoint.x, y: center.y - this.prevTapPoint.y });
            this.prevTapPoint = center;
            return this.options.maxDistanceFromPrevTap >= distanceFromPreviousTap;
        }
        else {
            this.prevTapPoint = center;
            return true;
        }
    };
    default_1.prototype._isValidInterval = function () {
        var now = performance.now();
        if (void 0 === this.prevTapTime) {
            this.prevTapTime = now;
            return true;
        }
        else {
            var interval = now - this.prevTapTime;
            this.prevTapTime = now;
            return interval < this.options.waitNextTapTime;
        }
    };
    default_1.prototype.recognize = function (input, emit) {
        var inputType = input.inputType, x = input.x, y = input.y;
        this.computed = this.compute([compute.ComputeMaxLength, compute.ComputeDistance], input);
        if (shared.INPUT_END !== inputType)
            return;
        this.status = shared.STATUS_POSSIBLE;
        if (this.test(input)) {
            this.cancelCountDownToFail();
            if (this._isValidDistanceFromPrevTap({ x: x, y: y }) && this._isValidInterval()) {
                this.tapCount++;
            }
            else {
                this.tapCount = 1;
            }
            if (0 === this.tapCount % this.options.tapTimes) {
                this.status = shared.STATUS_RECOGNIZED;
                emit(this.options.name, tslib.__assign(tslib.__assign({}, this.computed), { tapCount: this.tapCount }));
                this.reset();
            }
            else {
                this.countDownToFail();
            }
        }
        else {
            this.reset();
            this.status = shared.STATUS_FAILED;
        }
    };
    default_1.prototype.countDownToFail = function () {
        var _this = this;
        this._countDownToFailTimer = setTimeout(function () {
            _this.status = shared.STATUS_FAILED;
            _this.reset();
        }, this.options.waitNextTapTime);
    };
    default_1.prototype.cancelCountDownToFail = function () {
        clearTimeout(this._countDownToFailTimer);
    };
    default_1.prototype.reset = function () {
        this.tapCount = 0;
        this.prevTapPoint = void 0;
        this.prevTapTime = void 0;
    };
    default_1.prototype.test = function (input) {
        var startInput = input.startInput, pointLength = input.pointLength;
        var deltaTime = input.timestamp - startInput.timestamp;
        var _a = this.computed, maxPointLength = _a.maxPointLength, distance = _a.distance;
        return maxPointLength === this.options.pointLength &&
            0 === pointLength &&
            this.options.maxDistance >= distance &&
            this.options.maxPressTime > deltaTime;
    };
    return default_1;
}(Recognizer));

exports.default = default_1;
