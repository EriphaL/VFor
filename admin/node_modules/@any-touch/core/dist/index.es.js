import { __extends, __assign, __rest, __values, __read } from 'tslib';
import AnyEvent from 'any-event';
import { MOUSE_DOWN, MOUSE_MOVE, MOUSE_UP, INPUT_START, INPUT_MOVE, INPUT_END, INPUT_CANCEL, SUPPORT_TOUCH, CLIENT_X, CLIENT_Y, isRegExp, isFunction, TOUCH_START, TOUCH_MOVE, TOUCH_END, TOUCH_CANCEL, TOUCH } from '@any-touch/shared';

var default_1 = (function () {
    function default_1() {
    }
    return default_1;
}());

var default_1$1 = (function (_super) {
    __extends(default_1, _super);
    function default_1() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    default_1.prototype.load = function (event) {
        var targets = [];
        var points = Array.from(event.touches).map(function (_a) {
            var clientX = _a.clientX, clientY = _a.clientY, target = _a.target;
            targets.push(target);
            return { clientX: clientX, clientY: clientY, target: target };
        });
        var changedPoints = Array.from(event.changedTouches).map(function (_a) {
            var clientX = _a.clientX, clientY = _a.clientY, target = _a.target;
            return ({ clientX: clientX, clientY: clientY, target: target });
        });
        return {
            inputType: event.type.replace('touch', ''),
            changedPoints: changedPoints,
            points: points,
            nativeEvent: event,
            target: event.target,
            targets: targets
        };
    };
    return default_1;
}(default_1));

var default_1$2 = (function (_super) {
    __extends(default_1, _super);
    function default_1() {
        var _this = _super.call(this) || this;
        _this.target = null;
        _this.isPressed = false;
        return _this;
    }
    default_1.prototype.load = function (event) {
        var clientX = event.clientX, clientY = event.clientY, type = event.type, button = event.button, target = event.target;
        var points = [{ clientX: clientX, clientY: clientY, target: target }];
        var inputType;
        if (MOUSE_DOWN === type && 0 === button) {
            this.target = target;
            this.isPressed = true;
            inputType = INPUT_START;
        }
        else if (this.isPressed) {
            if (MOUSE_MOVE === type) {
                inputType = INPUT_MOVE;
            }
            else if (MOUSE_UP === type) {
                points = [];
                inputType = INPUT_END;
                this.isPressed = false;
            }
        }
        var changedPoints = this.prevPoints || [{ clientX: clientX, clientY: clientY, target: target }];
        this.prevPoints = [{ clientX: clientX, clientY: clientY, target: target }];
        if (void 0 !== inputType) {
            return {
                inputType: inputType,
                changedPoints: changedPoints,
                points: points,
                target: this.target,
                targets: [this.target],
                nativeEvent: event
            };
        }
    };
    return default_1;
}(default_1));

var default_1$3 = (function () {
    function default_1() {
        var Input = SUPPORT_TOUCH ? default_1$1 : default_1$2;
        this.adapter = new Input();
        this.id = 0;
    }
    default_1.prototype.transform = function (event) {
        this.prevInput = this.activeInput;
        var baseInputWithoutId = this.adapter.load(event);
        if (void 0 !== baseInputWithoutId) {
            var id = Number.MAX_SAFE_INTEGER > this.id ? ++this.id : 1;
            var baseInput = __assign(__assign({}, baseInputWithoutId), { id: id });
            var pureInput = extendInput(baseInput);
            this.activeInput = pureInput;
            var isStart = pureInput.isStart, pointLength = pureInput.pointLength;
            if (isStart) {
                this.startInput = pureInput;
                this.prevInput = void 0;
                if (1 < pointLength) {
                    this.startMultiInput = pureInput;
                }
                else {
                    this.startMultiInput = void 0;
                }
            }
            return __assign(__assign({}, pureInput), { prevInput: this.prevInput, startMultiInput: this.startMultiInput, startInput: this.startInput });
        }
    };
    return default_1;
}());
function getCenter(points) {
    var length = points.length;
    if (0 < length) {
        if (1 === length) {
            var _a = points[0], clientX = _a.clientX, clientY = _a.clientY;
            return { x: Math.round(clientX), y: Math.round(clientY) };
        }
        var countPoint = points.reduce(function (countPoint, point) {
            countPoint.x += point[CLIENT_X];
            countPoint.y += point[CLIENT_Y];
            return countPoint;
        }, { x: 0, y: 0 });
        return { x: Math.round(countPoint.x / length), y: Math.round(countPoint.y / length) };
    }
}
function extendInput(inputBase) {
    var inputType = inputBase.inputType, points = inputBase.points, changedPoints = inputBase.changedPoints, nativeEvent = inputBase.nativeEvent;
    var pointLength = points.length;
    var isStart = INPUT_START === inputType;
    var isEnd = (INPUT_END === inputType && 0 === pointLength) || INPUT_CANCEL === inputType;
    var timestamp = performance.now();
    var _a = getCenter(points) || getCenter(changedPoints), x = _a.x, y = _a.y;
    var currentTarget = nativeEvent.currentTarget;
    return __assign(__assign({}, inputBase), { x: x, y: y,
        timestamp: timestamp,
        isStart: isStart, isEnd: isEnd,
        pointLength: pointLength,
        currentTarget: currentTarget,
        getOffset: function (el) {
            if (el === void 0) { el = currentTarget; }
            var rect = el.getBoundingClientRect();
            return { x: x - Math.round(rect.left), y: y - Math.round(rect.top) };
        } });
}

function dispatchDomEvent (el, payload, eventInit) {
    var target = payload.target, currentTarget = payload.currentTarget, type = payload.type, data = __rest(payload, ["target", "currentTarget", "type"]);
    var event;
    if ('createEvent' in document) {
        event = document.createEvent('HTMLEvents');
        event.initEvent(type, eventInit === null || eventInit === void 0 ? void 0 : eventInit.bubbles, eventInit === null || eventInit === void 0 ? void 0 : eventInit.cancelable);
    }
    else {
        event = new Event(type, eventInit);
    }
    Object.assign(event, data, {
        match: function () {
            return payload.targets.every(function (target) {
                return event.currentTarget.contains(target);
            });
        }
    });
    return el.dispatchEvent(event);
}

function canPreventDefault (event, options) {
    if (!options.isPreventDefault)
        return false;
    var isPreventDefault = true;
    if (null !== event.target) {
        var preventDefaultExclude = options.preventDefaultExclude;
        if (isRegExp(preventDefaultExclude)) {
            if ('tagName' in event.target) {
                var tagName = event.target.tagName;
                isPreventDefault = !preventDefaultExclude.test(tagName);
            }
        }
        else if (isFunction(preventDefaultExclude)) {
            isPreventDefault = !preventDefaultExclude(event);
        }
    }
    return isPreventDefault;
}

var TOUCH_EVENT_NAMES = [TOUCH_START, TOUCH_MOVE, TOUCH_END, TOUCH_CANCEL];
function bindElement (el, callback, options) {
    if (SUPPORT_TOUCH) {
        TOUCH_EVENT_NAMES.forEach(function (eventName) {
            el.addEventListener(eventName, callback, options);
        });
        return function () {
            TOUCH_EVENT_NAMES.forEach(function (eventName) {
                el.removeEventListener(eventName, callback);
            });
        };
    }
    else {
        el.addEventListener(MOUSE_DOWN, callback, options);
        window.addEventListener(MOUSE_MOVE, callback, options);
        window.addEventListener(MOUSE_UP, callback, options);
        return function () {
            el.removeEventListener(MOUSE_DOWN, callback);
            window.removeEventListener(MOUSE_MOVE, callback);
            window.removeEventListener(MOUSE_UP, callback);
        };
    }
}

function use(instanceOrClass, Recognizer, options) {
    var name = options === null || options === void 0 ? void 0 : options.name;
    if (void 0 !== name && void 0 !== instanceOrClass.recognizerMap[name])
        return;
    var instance = new Recognizer(options);
    instanceOrClass.recognizerMap[instance.name] = instance;
    instance.recognizerMap = instanceOrClass.recognizerMap;
    instanceOrClass.recognizers.push(instanceOrClass.recognizerMap[instance.name]);
}
function removeUse(instanceOrClass, recognizerName) {
    var e_1, _a;
    if (void 0 === recognizerName) {
        instanceOrClass.recognizers = [];
        instanceOrClass.recognizerMap = {};
    }
    else {
        try {
            for (var _b = __values(instanceOrClass.recognizers.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var _d = __read(_c.value, 2), index = _d[0], recognizer = _d[1];
                if (recognizerName === recognizer.options.name) {
                    instanceOrClass.recognizers.splice(index, 1);
                    delete instanceOrClass.recognizerMap[recognizerName];
                    break;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
}

function emit2(at, payload) {
    var type = payload.type, target = payload.target, targets = payload.targets;
    at.emit(type, payload, function (data) {
        if (void 0 !== (data === null || data === void 0 ? void 0 : data.target)) {
            var currentTarget_1 = data.target;
            return targets.every(function (target) { return currentTarget_1.contains(target); });
        }
        return true;
    });
    var AT_AFTER = 'at:after';
    at.emit(AT_AFTER, payload);
    if (!!at.options.domEvents
        && void 0 !== at.el
        && null !== target) {
        dispatchDomEvent(target, payload, at.options.domEvents);
        dispatchDomEvent(target, __assign(__assign({}, payload), { type: AT_AFTER }), at.options.domEvents);
    }
}

var DEFAULT_OPTIONS = {
    domEvents: { bubbles: true, cancelable: true },
    isPreventDefault: true,
    preventDefaultExclude: /^(?:INPUT|TEXTAREA|BUTTON|SELECT)$/
};
var AnyTouch = (function (_super) {
    __extends(AnyTouch, _super);
    function AnyTouch(el, options) {
        var _this = _super.call(this) || this;
        _this.recognizerMap = {};
        _this.recognizers = [];
        _this.cacheComputedFunctionGroup = Object.create(null);
        _this.el = el;
        _this.input = new default_1$3();
        _this.options = __assign(__assign({}, DEFAULT_OPTIONS), options);
        _this.recognizerMap = AnyTouch.recognizerMap;
        _this.recognizers = AnyTouch.recognizers;
        if (void 0 !== el) {
            el.style.webkitTapHighlightColor = 'rgba(0,0,0,0)';
            var supportsPassive_1 = false;
            try {
                var opts = {};
                Object.defineProperty(opts, 'passive', ({
                    get: function () {
                        supportsPassive_1 = true;
                    }
                }));
                window.addEventListener('_', function () { return void 0; }, opts);
            }
            catch (_a) { }
            _this.on('unbind', bindElement(el, _this.catchEvent.bind(_this), !_this.options.isPreventDefault && supportsPassive_1 ? { passive: true } : false));
        }
        return _this;
    }
    AnyTouch.prototype.use = function (Recognizer, options) {
        use(this, Recognizer, options);
    };
    AnyTouch.prototype.removeUse = function (name) {
        removeUse(this, name);
    };
    AnyTouch.prototype.catchEvent = function (event) {
        var e_1, _a;
        var _this = this;
        if (canPreventDefault(event, this.options)) {
            event.preventDefault();
        }
        var input = this.input.transform(event);
        if (void 0 !== input) {
            var AT_TOUCH = "at:" + TOUCH;
            var AT_TOUCH_WITH_STATUS = AT_TOUCH + input.inputType;
            this.emit(AT_TOUCH, input);
            this.emit(AT_TOUCH_WITH_STATUS, input);
            var domEvents = this.options.domEvents;
            if (false !== domEvents) {
                var target = event.target;
                if (null !== target) {
                    dispatchDomEvent(target, __assign(__assign({}, input), { type: AT_TOUCH }), domEvents);
                    dispatchDomEvent(target, __assign(__assign({}, input), { type: AT_TOUCH_WITH_STATUS }), domEvents);
                }
            }
            var cacheComputedGroup = Object.create(null);
            var _loop_1 = function (recognizer) {
                if (recognizer.disabled)
                    return "continue";
                recognizer.computedGroup = cacheComputedGroup;
                recognizer.computeFunctionMap = this_1.cacheComputedFunctionGroup;
                recognizer.recognize(input, function (type, ev) {
                    var payload = __assign(__assign(__assign({}, input), ev), { type: type, baseType: recognizer.name });
                    Object.freeze(payload);
                    if (void 0 === _this.beforeEachHook) {
                        emit2(_this, payload);
                    }
                    else {
                        _this.beforeEachHook(recognizer, function () {
                            emit2(_this, payload);
                        });
                    }
                });
                cacheComputedGroup = recognizer.computedGroup;
                this_1.cacheComputedFunctionGroup = recognizer.computeFunctionMap;
            };
            var this_1 = this;
            try {
                for (var _b = __values(this.recognizers), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var recognizer = _c.value;
                    _loop_1(recognizer);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    };
    AnyTouch.prototype.beforeEach = function (hook) {
        this.beforeEachHook = hook;
    };
    AnyTouch.prototype.get = function (name) {
        return this.recognizerMap[name];
    };
    AnyTouch.prototype.set = function (options) {
        this.options = __assign(__assign({}, this.options), options);
    };
    AnyTouch.prototype.destroy = function () {
        this.emit('unbind');
        this.listenersMap = {};
    };
    AnyTouch.version = '0.7.1';
    AnyTouch.recognizers = [];
    AnyTouch.recognizerMap = {};
    AnyTouch.use = function (Recognizer, options) {
        use(AnyTouch, Recognizer, options);
    };
    AnyTouch.removeUse = function (recognizerName) {
        removeUse(AnyTouch, recognizerName);
    };
    return AnyTouch;
}(AnyEvent));

export default AnyTouch;
