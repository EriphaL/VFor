import { getAngle, radianToAngle, getVLength, getDirection } from '@any-touch/vector';
import { INPUT_START, INPUT_MOVE, CLIENT_X, CLIENT_Y, NONE, round2, COMPUTE_INTERVAL } from '@any-touch/shared';

function computeAngle (_a) {
    var startV = _a.startV, prevV = _a.prevV, activeV = _a.activeV;
    var deltaAngle = Math.round(getAngle(activeV, prevV));
    var angle = Math.round(getAngle(activeV, startV));
    return { angle: angle, deltaAngle: deltaAngle };
}

function ComputeDeltaXY() {
    return function (input) {
        var prevInput = input.prevInput;
        var deltaX = 0;
        var deltaY = 0;
        var deltaXYAngle = 0;
        if (void 0 !== prevInput) {
            deltaX = input.x - prevInput.x;
            deltaY = input.y - prevInput.y;
            if (0 !== deltaX || 0 !== deltaY) {
                var deltaXY = Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
                deltaXYAngle = Math.round(radianToAngle(Math.acos(Math.abs(deltaX) / deltaXY)));
            }
        }
        return { deltaX: deltaX, deltaY: deltaY, deltaXYAngle: deltaXYAngle };
    };
}
ComputeDeltaXY._id = "ComputeDeltaXY";

function computeDistance() {
    var displacementX = 0;
    var displacementY = 0;
    var distanceX = 0;
    var distanceY = 0;
    var distance = 0;
    var overallDirection = NONE;
    return function (input) {
        var inputType = input.inputType, startInput = input.startInput;
        if (INPUT_START === inputType) {
            displacementX = 0;
            displacementY = 0;
            distanceX = 0;
            distanceY = 0;
            distance = 0;
            overallDirection = NONE;
        }
        else if (INPUT_MOVE === inputType) {
            displacementX = Math.round(input.points[0][CLIENT_X] - startInput.points[0][CLIENT_X]);
            displacementY = Math.round(input.points[0][CLIENT_Y] - startInput.points[0][CLIENT_Y]);
            distanceX = Math.abs(displacementX);
            distanceY = Math.abs(displacementY);
            distance = Math.round(getVLength({ x: distanceX, y: distanceY }));
            overallDirection = getDirection(displacementX, displacementY);
        }
        return {
            displacementX: displacementX, displacementY: displacementY, distanceX: distanceX, distanceY: distanceY, distance: distance, overallDirection: overallDirection
        };
    };
}
computeDistance._id = "computeDistance";

function computeMaxLength() {
    var maxPointLength = 0;
    return function (input) {
        var inputType = input.inputType;
        if (INPUT_START === inputType) {
            maxPointLength = input.pointLength;
        }
        return { maxPointLength: maxPointLength };
    };
}
computeMaxLength._id = "computeMaxLength";

function computeScale(_a) {
    var startV = _a.startV, prevV = _a.prevV, activeV = _a.activeV;
    var deltaScale = round2(getVLength(activeV) / getVLength(prevV));
    var scale = round2(getVLength(activeV) / getVLength(startV));
    return { scale: scale, deltaScale: deltaScale };
}

function ComputeVAndDir() {
    var velocityX = 0;
    var velocityY = 0;
    var speedX = 0;
    var speedY = 0;
    var direction;
    var _lastValidInput;
    return function (input) {
        if (void 0 !== input) {
            var inputType = input.inputType;
            _lastValidInput = _lastValidInput || input.startInput;
            var deltaTime = input.timestamp - _lastValidInput.timestamp;
            if (INPUT_MOVE === inputType && COMPUTE_INTERVAL < deltaTime) {
                var deltaX = input.x - _lastValidInput.x;
                var deltaY = input.y - _lastValidInput.y;
                speedX = Math.round(deltaX / deltaTime * 100) / 100;
                speedY = Math.round(deltaY / deltaTime * 100) / 100;
                velocityX = Math.abs(speedX);
                velocityY = Math.abs(speedY);
                direction = getDirection(deltaX, deltaY) || (direction);
                _lastValidInput = input;
            }
        }
        return { velocityX: velocityX, velocityY: velocityY, speedX: speedX, speedY: speedY, direction: direction };
    };
}
ComputeVAndDir._id = "ComputeVAndDir";

function computeVector(input) {
    return {
        x: input.points[1][CLIENT_X] - input.points[0][CLIENT_X],
        y: input.points[1][CLIENT_Y] - input.points[0][CLIENT_Y]
    };
}

function ComputeVectorForMutli() {
    return function (input) {
        var prevInput = input.prevInput, startMultiInput = input.startMultiInput;
        if (void 0 !== startMultiInput &&
            void 0 !== prevInput &&
            input.id !== startMultiInput.id &&
            1 < input.pointLength) {
            return {
                startV: computeVector(startMultiInput),
                prevV: computeVector(prevInput),
                activeV: computeVector(input)
            };
        }
    };
}
ComputeVectorForMutli._id = "ComputeVectorForMutli";

export { ComputeDeltaXY, computeDistance as ComputeDistance, computeMaxLength as ComputeMaxLength, ComputeVAndDir, ComputeVectorForMutli, computeAngle, computeScale, computeVector };
