'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tslib = require('tslib');
var shared = require('@any-touch/shared');
var compute = require('@any-touch/compute');
var Recognizer = _interopDefault(require('@any-touch/recognizer'));

var DEFAULT_OPTIONS = {
    name: 'swipe',
    threshold: 10,
    velocity: 0.3,
    pointLength: 1,
};
var default_1 = (function (_super) {
    tslib.__extends(default_1, _super);
    function default_1(options) {
        return _super.call(this, tslib.__assign(tslib.__assign({}, DEFAULT_OPTIONS), options)) || this;
    }
    default_1.prototype.test = function (input) {
        var inputType = input.inputType;
        if (shared.INPUT_END !== inputType)
            return false;
        var _a = this.computed, velocityX = _a.velocityX, velocityY = _a.velocityY, maxPointLength = _a.maxPointLength, distance = _a.distance;
        return this.options.pointLength === maxPointLength &&
            this.options.threshold < distance &&
            this.options.velocity < Math.max(velocityX, velocityY);
    };
    default_1.prototype.recognize = function (input, emit) {
        this.computed = this.compute([compute.ComputeMaxLength, compute.ComputeVAndDir, compute.ComputeDistance], input);
        if (this.test(input)) {
            emit(this.options.name, this.computed);
            emit(this.options.name + this.computed.direction, this.computed);
        }
    };
    return default_1;
}(Recognizer));

exports.default = default_1;
