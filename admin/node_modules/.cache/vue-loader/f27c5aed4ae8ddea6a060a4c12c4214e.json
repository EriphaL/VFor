{"remainingRequest":"/Users/eripha/Desktop/project/routine/admin/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/eripha/Desktop/project/routine/admin/src/components/Call.vue?vue&type=style&index=0&id=686670e4&scoped=true&lang=css&","dependencies":[{"path":"/Users/eripha/Desktop/project/routine/admin/src/components/Call.vue","mtime":1593738942789},{"path":"/Users/eripha/Desktop/project/routine/admin/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/eripha/Desktop/project/routine/admin/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/eripha/Desktop/project/routine/admin/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/eripha/Desktop/project/routine/admin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/eripha/Desktop/project/routine/admin/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKLmJhci1wb3NpdGl2ZSB7CiAgZmlsbDogc3RlZWxibHVlOwogIHRyYW5zaXRpb246IHIgMC4ycyBlYXNlLWluLW91dDsKfQoKLmJhci1wb3NpdGl2ZTpob3ZlciB7CiAgZmlsbDogYnJvd247Cn0KCi5zdmctY29udGFpbmVyIHsKICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7CiAgcG9zaXRpb246IHJlbGF0aXZlOwogIHdpZHRoOiAxMDAlOwogIHBhZGRpbmctYm90dG9tOiAxJTsKICB2ZXJ0aWNhbC1hbGlnbjogdG9wOwogIG92ZXJmbG93OiBoaWRkZW47Cn0K"},{"version":3,"sources":["Call.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiRA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Call.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div ref=\"container\" class=\"svg-container\" align=\"center\">\n    <h1>{{ title }}</h1>\n    <svg\n      ref=\"mainsvg\"\n      id=\"mainsvg\"\n      v-if=\"redrawToggle === true\"\n      :width=\"svgWidth\"\n      :height=\"svgHeight\"\n    >\n      <defs>\n        <marker\n          id=\"arrowId\"\n          viewBox=\"0 0 10 10\"\n          refX=\"1\"\n          refY=\"5\"\n          markerWidth=\"6\"\n          markerHeight=\"6\"\n          orient=\"auto\"\n        >\n          <path d=\"M 0 0 L 10 5 L 0 10 z\" />\n        </marker>\n      </defs>\n    </svg>\n  </div>\n</template>\n\n<script>\n/*eslint-disable */\nimport * as d3 from \"d3\";\nexport default {\n  name: \"Call\",\n  props: {\n    title: String,\n    xKey: String,\n    yKey: String,\n    data: Array,\n    nodes: { type: Array, required: true },\n    edges: { type: Array, required: true },\n    res: { type: Array }\n  },\n  mounted() {\n      \n    //   vue中获取元素的方法\n    // this.$refs.container === document.getElementById(\"container\")\n    this.svgWidth = this.$refs.container.offsetWidth * 0.8;\n    this.AddResizeListener();\n    this.render();\n  },\n  data: () => ({\n    svgWidth: 0,\n    // g: {},\n    timeScale: [],\n    redrawToggle: true,\n    margin: {\n      top: 0,\n      right: 0,\n      bottom: 50,\n      left: 50\n    }\n\n  }),\n  methods: {\n    render() {\n      const svg = d3.select(\"#mainsvg\");\n\n      let innerWidth = this.svgWidth - this.margin.left - this.margin.right;\n      let innerHeight = this.svgHeight - this.margin.top - this.margin.bottom;\n      let xTrans = innerHeight + this.margin.top;\n      let yTrans = innerWidth - this.margin.left;\n\n\n      console.log(this.edges.map(d=>this.xScale(d.data.time)));\n      \n\n      const g = svg\n        .append(\"g\")\n        .attr(\"id\", \"maingroup\")\n        .attr(\n          \"transform\",\n          `translate(${this.margin.left}, ${this.margin.top})`\n        );\n\n      const xAxis = d3\n        .axisBottom(this.xScale)\n        .ticks(\n          [\n            ...new Set(\n              this.edges.map(d => {\n                return d.data.time;\n              })\n            )\n          ].length\n        )\n        //又有说法是刻度的数量\n        //   .ticks(1) ;\n        // 取得定义域中的典型值，指定的计数count是只是一个提示;规模可能取决于输入域返回更多或更少的值\n        //并不精确\n        // .ticks(parseInt(allDates.length) / 4)\n        .tickSize(-xTrans);\n      // .text(d => d.name);\n      //   .tickFormat(d3.format(\"%4d\"));\n      g.append(\"g\")\n        .call(xAxis)\n        .attr(\"transform\", `translate(0, ${xTrans})`);\n\n      const yAxis = d3\n        //   .paddingOuter(0)\n        .axisLeft(this.yScale)\n        .tickSize(-yTrans);\n      g.append(\"g\").call(yAxis);\n\n      g.selectAll(\".tick text\").attr(\"font-size\", \"1.3rem\");\n      // 添加折线\n      g.append(\"path\").attr(\"id\", \"alterPath\");\n\n\n      // 散点\n      let getX = [],\n        getY = [];\n      let circleUpdates = g.selectAll(\"circle\").data(this.edges);\n      let sourceEnter = circleUpdates\n        .enter()\n        .append(\"circle\")\n        .attr(\"transform\", `translate(${this.margin.left},50)`)\n        // xScale必须包裹在外面，数据到像素的对应,先取值xValue然后调用映射到坐标\n        .attr(\"cx\", d => {\n          getX.push(this.xScale(d.data.time));\n          return this.xScale(d.data.time);\n        })\n        .attr(\"cy\", d => {\n          //undefined\n          // console.log(this.xScale(d.source));\n          getY.push(this.yScale(d.source));\n          //   console.log(this.yScale(d.source));\n          return this.yScale(d.source);\n        })\n        .attr(\"r\", 5)\n        .attr(\"fill\", \"#7289AB\")\n        .attr(\"opacity\", 0.5);\n\n      //   console.log(\"getX:\" + getX);\n      //   console.log(\"getY:\" + getY);\n      const startLocation = [];\n      for (let i = 0; i < getX.length; i++) {\n        let cur = { x1: getX[i], y1: getY[i] };\n        startLocation.push(cur);\n      }\n      //   console.log(startLocation);\n\n      getY = [];\n      getX = [];\n      let targetEnter = circleUpdates\n        .enter()\n        .append(\"circle\")\n        .attr(\"transform\", `translate(${this.margin.left},50)`)\n        // xScale必须包裹在外面，数据到像素的对应,先取值xValue然后调用映射到坐标\n        .attr(\"cx\", d => {\n          getX.push(this.xScale(d.data.time));\n          return this.xScale(d.data.time);\n        })\n        .attr(\"cy\", d => {\n          // undefined\n          //   console.log(this.yScale(d.target));\n          getY.push(this.yScale(d.target));\n\n          return this.yScale(d.target);\n        })\n        .attr(\"r\", 15)\n        .attr(\"fill\", \"#333333\")\n        .attr(\"opacity\", 0.5);\n      // .attr(\"marker-end\", \"url(#resolved)\") //根据箭头标记的id号标记箭头\n      // .text(d => {\n      //   return d.target;\n      // });\n\n      const endLocation = [];\n      for (let i = 0; i < getX.length; i++) {\n        let cur = { x2: getX[i], y2: getY[i] };\n        endLocation.push(cur);\n      }\n      //   console.log(endLocation);\n\n      const location = [];\n      for (let i = 0; i < startLocation.length; i++) {\n        location.push(Object.assign(startLocation[i], endLocation[i]));\n      }\n      console.log(\"location\");\n      //   console.log(location);\n\n      function arc(x1, y1, x2, y2) {\n        const r = Math.hypot(x1 - x2, y1 - y2) * 2;\n        // return `M${x1},${y1} A${r},${r} 0,0,1 ${x2},${y2}`;\n        return `M${x1},${y1}  ${x2},${y2}`;\n\n      }\n\n      g\n        // .append(\"g\")\n        .attr(\"fill\", \"none\")\n        .selectAll(\"path\")\n        .data(location)\n        .join(\"path\")\n        .attr(\"transform\", `translate(${this.margin.left},50)`)\n        .attr(\"stroke\", \"black\")\n        .attr(\"marker-end\", \"url(#arrowId)\")\n        .attr(\"d\", d => {\n          //   console.log();\n          return arc(\n            // x(d.x1),\n            // y(d.y1),\n            // // 终点坐标\n            // x(d.x2),\n            // y(d.y2)\n            d.x1,d.y1,d.x2,d.y2\n          );\n        });\n      // 起始原点\n      svg\n        .append(\"g\")\n        .attr(\"fill\", \"currentColor\")\n        .selectAll(\"circle\")\n        .data(location)\n        .join(\"circle\")\n        .attr(\"r\", 1.75)\n        .attr(\"cx\", d => d.x1)\n        .attr(\"cy\", d => d.y1);\n    },\n    // 即响应式绘制\n    AddResizeListener() {\n      window.addEventListener(\"resize\", () => {\n        this.$data.redrawToggle = false;\n        setTimeout(() => {\n          this.$data.redrawToggle = true;\n          this.$data.svgWidth = this.$refs.container.offsetWidth * 0.8;\n          // 重新绘制\n        //   this.render();\n        }, 0);\n      });\n      //   console.log([...new Set(this.edges.map(d => d.data.time))].length);\n    }\n  },\n  computed: {\n    xScale() {\n      //   console.log(this.xValue);\n      return d3\n        .scaleBand()\n        .domain([...new Set(this.edges.map(d => d.data.time))])\n        .range([0, this.svgWidth - 2 * this.margin.left]);\n      // .nice();\n    },\n    // 通过线性比例尺自动生成\n    yScale() {\n      return d3\n        .scaleBand()\n        .domain(\n          this.nodes.map(d => {\n            // console.log(d);\n            return d.data.id;\n          })\n        )\n        .range([0, this.svgHeight - this.margin.bottom]);\n      // .padding(0);无效\n    },\n    svgHeight() {\n      return this.svgWidth / 1.61803398875; // 黄金比例\n    }\n  }\n};\n/*eslint-enable */\n</script>\n\n<style scoped>\n.bar-positive {\n  fill: steelblue;\n  transition: r 0.2s ease-in-out;\n}\n\n.bar-positive:hover {\n  fill: brown;\n}\n\n.svg-container {\n  display: inline-block;\n  position: relative;\n  width: 100%;\n  padding-bottom: 1%;\n  vertical-align: top;\n  overflow: hidden;\n}\n</style>\n"]}]}